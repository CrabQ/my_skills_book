# 经典算法题

## 剑指offer

### 001_二维数组查找

在一个二维数组中（每个一维数组的长度相同）,每一行都按照从左到右递增的顺序排序,每一列都按照从上到下递增的顺序排序。请完成一个函数,输入这样的一个二维数组和一个整数,判断数组中是否含有该整数。

```Python
# 从右上角开始,target更大,指针下移,更小则左移

def search(target, array):
     i = 0
     j = len(array[0]) - 1
     while i< len(array) and j >= 0:
         if array[i][j] == target:
             return True
         elif target > array[i][j]:
             i += 1
         else:
             j -= 1
     return False

if __name__ == '__main__':
    print(search(2, [[1, 2, 8, 9], [2, 4, 9, 12], [4, 7, 10, 13], [6, 8, 11, 15]]))
```

### 002_替换空格

请实现一个函数,将一个字符串中的每个空格替换成“%20”。例如,当字符串为We Are  Happy.则经过替换之后的字符串为We%20Are%20Happy。

```shell
# 先算出空格数量,然后遍历字符串填入新列表

def replace_space(s):
    s_len = len(s)
    space_count = 0
    for i in s:
        if i == ' ':
            space_count += 1

    s_len += 2*space_count
    # 替换为%20之后的字符串长度的列表
    new_s_list = [' '] * s_len
    j = 0
    for i in range(len(s)):
        if s[i] == ' ':
            new_s_list[j] = '%'
            new_s_list[j+1] = '2'
            new_s_list[j+2] = '0'
            j += 3
        else:
            new_s_list[j] = s[i]
            j += 1
    return ''.join(new_s_list)

if __name__ == '__main__':
    print(replace_space('We Are  Happy'))
    # We%20Are%20%20Happy
```

### 003_从尾到头打印链表

输入一个链表,按链表值从尾到头的顺序返回一个ArrayList

```python
# 使用递归的思想

class Node():
    def __init__(self, elem):
        self.elem = elem
        self.next = None

def print_single_link_list_from_tail_to_head(list_node, array=None):
    if array == None:
        array = []
    if list_node:
        print_single_link_list_from_tail_to_head(list_node.next, array)
        array.append(list_node.elem)
    return array
```

### 004_重建二叉树

输入某二叉树的前序遍历和中序遍历的结果,请重建出该二叉树.假设输入的前序遍历和中序遍历的结果中都不含重复的数字.

例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6},则重建二叉树并返回

```Python
# 用前序遍历找到根结点
# 用根结点在中序遍历中切开左右子树,递归重建二叉树

# 树结点
class TreeNode():
    def __init__(self, node):
        self.val = node
        self.left = None
        self.right = None

# 递归查找
def reconstruct_binary_tree(pre, tin):
    if not pre:
        return

    root_val = pre[0]
    root = TreeNode(root_val)
    for i in range(len(tin)):
        if tin[i] == root_val:
            root.left = reconstruct_binary_tree(pre[1:i+1], tin[:i])
            root.right = reconstruct_binary_tree(pre[i+1:], tin[i+1:])
            break

    return root

# 前序遍历
def pre_order(root):
    if root:
        print(root.val, end='')
        pre_order(root.left)
        pre_order(root.right)

# 中序遍历
def in_order(root):
    if root:
        in_order(root.left)
        print(root.val, end='')
        in_order(root.right)

if __name__ == '__main__':
    pre_order(reconstruct_binary_tree([1, 2, 4, 7, 3, 5, 6, 8], [4, 7, 2, 1, 5, 3, 8, 6]))
    print('')
    in_order(reconstruct_binary_tree([1, 2, 4, 7, 3, 5, 6, 8], [4, 7, 2, 1, 5, 3, 8, 6]))
```

### 005_用两个栈实现队列

用两个栈来实现一个队列,完成队列的Push和Pop操作.队列中的元素为int类型

```Python
# 一个栈stack1用来存储 pop时弹出stack1所有数据到stack2,当stack2为空,pop出stack1存储在stack2中

class CQueue():
    def __init__(self):
        self.stack_1 = []
        self.stack_2 = []

    def append_tail(self, value):
        self.stack_1.append(value)

    def delete_head(self):
        if not self.stack_2:
            while self.stack_1:
                self.stack_2.append(self.stack_1.pop(-1))
        if not self.stack_2:
            return False
        return self.stack_2.pop(-1)
```

### 006_旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转.输入一个非减排序的数组的一个旋转,输出旋转数组的最小元素.例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转,该数组的最小值为1.NOTE：给出的所有元素都大于0,若数组大小为0,请返回0

```python
# if mid大于high, low = mid - 1
# if mid小于high, high = mid
# 直到mid=high，取此位置的数

def min_arrays(array):
    low, high = 0, len(array)-1

    if not array:
        return 0

    while low < high:
        mid = (low+high)//2
        if array[mid]>array[high]:
            low = mid+1
        elif array[mid]<array[high]:
            high = mid
        else:
            if array[high-1]>array[high]:
                break
            # 如果[high-1] = array[high]
            high -= 1
    return array[high]
```

### 007_斐波拉契数列

大家都知道斐波那契数列,现在要求输入一个整数n,请你输出斐波那契数列的第n项（从0开始,第0项为0）. n<=39

```python
def Fibonacci(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for i in range(n-1):
        a, b = b, a+b
    return b
```

### 008_跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

```python
# 假设对于第n级台阶，总共有f(n)种跳法.
# 那么f(n) = f(n-1) + f(n-2)，其中f(1)=1,f(2)=2

def num_ways(n):
    if n <= 2:
        return n
    a , b = 1, 2
    for i in range(n-2):
        a, b = b, a+b
    return b
```

### 009_变态跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法

```python
# f(1)=1, f(2)=2, f(3)=4, f(4)=8 设n+1级f(n+1),有
# f(n+1) = f(1) + f(2) + ... + f(n)
# f(n+2) = f(1) + f(2) + ... + f(n+1)
# f(n+2)= 2f(1) + 2f(2) + ... + 2f(n)
# 故得f(n+2) = 2f(n+1)

def num_ways(n):
    if n == 1:
        return 1
    return 2*num_ways(n-1)

def num_ways_2(n):
    if n == 1:
        return 1
    a = 1
    for _ in range(n-1):
        a = 2*a
    return a
```
