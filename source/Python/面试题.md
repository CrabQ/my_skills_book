# 面试题

## 计算机基础知识

位和字节

```shell
8 bit = 1 Bytes
二进制数系统中,位简记为b,也称为比特,每个二进制数字0或1就是一个位(bit)
位是数据存储的最小单位,其中8 bit 就称为一个字节(Byte)
```

ascii, unicode, utf-8, gbk区别

```shell
ascii：
在计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit），有0和1两种状态，因此，8个二进制位可以组合出256种状态，这被称为字节（byte)。上个世纪60年代，美国制定了一套字符编码，对英文字符与二进制之间做了联系，这被称为ASCII码，一直沿用至今。
ASCII码一共规定了128个字符，比如SPACE是32，A是65，这128个符号只咱用了一个字节的后面七位，最前面的一位统一规定为0。

unicode：
世界上有多种编码方法，同一个二进制数字可以被解释称不同的符号。因此，在打开一个文本文件时候，就必须知道它的编码方式，用错误的编码方式打开，就会出现乱码。
Unicode编码，这是一种所有符号的编码。
Unicode显然是一个巨大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如U+0041表示英语的大写字母A，U+4e25表示汉字严。
在Unicode庞大的字符集的优势下，还存在一个问题，比如一个汉字，“严”的Unicode是十六进制4e25，转成二进制足足有15位，也就是，这个符号需要2个字节，表示其他字符还存在3个字节或者更多。计算机怎么区别三个字节表示的是同一个符号而不是分开表示三个呢？如果Unicode统一规定，每个符号用3个字节表示，但是某些字母显然不需要3个，那么就浪费了空间，文本文件大小超出了很多，这显然是不合理的。直到UTF8字符编码出现了。

utf-8：
UTF8的最大特点是，它是一种变长编码，可以使用1-4个字节表示一个符号，根据不同的符号来变化字节长度。
UTF8编码规则只有两条：
1）对于单字节的符号，字节的第一位设为0，后面的7位为这个符号的Unicode码。因此，对于英文字母，UTF8编码和ASCII编码是相同的。
2）对于非单字节（假设字节长度为N）的符号，第一个字节的前N位都设为1，第N+1设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制，全部为这个符号的Unicode码。

gbk：
GBK编码是对GB2312的扩展，完全兼容GB2312。采用双字节编码方案，剔出xx7F码位，共23940个码位，共收录汉字和图形符号21886个，GBK编码方案于1995年12月15日发布。它几乎完美支持汉字，因此经常会遇见GBK与Unicode的转换。

1，各个编码之间的二进制，是不能互相识别的，会产生乱码。
2，文件的存储，传输，不能是unicode （只能是utf-8 utf-16 gbk gbk2312 ascii等）
```

字节码和机器码

```shell
字节码是一种中间状态(中间码)的二进制代码(文件). 需要直译器转译之后才能成为机器码
```

## python语言

python和其他编程语言对比

```shell
python语言，是一种面向对象、直译式计算机程序设计语言，Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言，它能够很轻松的把用其他语言制作的各种模块（尤其是C/C++）轻松地联结在一起。常见的一种应用情形是，使用python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写。
Python是完全面向对象的语言。函数、模块、数字、字符串都是对象。并且完全支持继承、重载、派生、多继承，有益于增强源代码的复用性。Python支持重载运算符和动态类型。相对于Lisp这种传统的函数式编程语言，Python对函数式设计只提供了有限的支持。有两个标准库(functools, itertools)提供了Haskell和Standard ML中久经考验的函数式程序设计工具。Python本身被设计为可扩充的。并非所有的特性和功能都集成到语言核心。Python提供了丰富的API和工具，以便程序员能够轻松地使用C语言、C++、Cython来编写扩充模块。Python编译器本身也可以被集成到其它需要脚本语言的程序内。因此，很多人还把Python作为一种“胶水语言”（glue language）使用。使用Python将其他语言编写的程序进行集成和封装。
```

解释型语言和编译型语言

```shell
编译型: 需要编译器, 先编译后运行, 一次编译无限运行, 修改需重新编译, 运行速度快. 如C, C++
解释型: 无需编译, 跨平台好, 一份代码到处运行, 速度慢, 依赖解释器运行
```

python解释器种类已经特点

```shell
CPython: 最广泛, C语言开发
IPython: 基于CPython之上的交互式解释器, 功能一致, 增强交互
PyPy: 采用JIT技术, 对python代码进行动态编译, 目标是执行速度
JPython: 运行在java平台上的python解释器, 可以把python代码编译成java字节码执行
IronPython: 类似JPython, 运行在微软.net平台上的python解释器
```

b, B, KB, MB, GB

```shell
8 bit = 1B
1024 B = 1KB
1024 KB = 1MB
1024 MB = 1GB
```

PEP8规范

```shell
使用space表示缩进, 而不是用tab
每层缩进4个空格
每行字符数不应超过79
函数和类之间应用两个空行隔开
同一个类中各方法用一个空行隔开
函数, 变量和属性用小写字母表示, 下划线命名法
```

python2和3中range的区别

```python
# 2返回列表, 3返回迭代器, 节约内存
```

Python2和Python3区别

```shell
一切返回生成式而非列表
1/2 py2:0 py3:0.5
py2:inpu_raw() py3:input()
py2:默认编码ASCII py3:utf-8
py3新增关键字nonlocal, 非局部变量
```

py2和py3中的int和long区别

```shell
int表示整型, long表示长整型
只有int
```

## 逻辑运算

OR AND 结果

```python
1 or 3 # 1
1 and 3 # 3
0 and 2 or 1 # 1
0 and 2 or 1 or 4 # 1
0 and 2 and 1 # 0
0 or False and 1 # False
```

## 三元表达式

三元运算编写格式

```python
# 结果 if 条件成立 else 条件不成立结果
True if 0>1 else False
```

一行代码实现数值交换

```python
a, b = 1, 2
a, b = b, a
```

xrange和range区别

```shell
xrange和range完全相同, range返回list, xrange返回生成器

py3, 取消了range, 重命名xrange为range
```

## 字符串

isinstance和type作用

```python
# isinstance 只能判断是否属于某个已知类型
# type 判断变量属于哪个内建类型
```

python内置的数据类型

```python
# 数字, 字符串, 布尔值, 列表, 元祖, 字典
```

以下程序存在什么问题

```python
def Lastllindextem(src, index):
    '''请返回传入 src 使用空格或者"\"切分后的倒数第 index 个子串'''
    return src.split('\')[-index]

# \' 应为 \\', 转义字符会转义'
```

打印字符串的所有排列组合

```python
def perm(s=''):
    if len(s) <= 1:
        return [s]
    sl = []
    for i in range(len(s)):
        for j in perm(s[0:i] + s[i + 1:]):
            sl.append(s[i] + j)
    return sl

perm_nums = perm('abc')
no_repeat_nums = list(set(perm_nums))
print('perm_nums', len(perm_nums), perm_nums)
print('no_repeat_nums', len(no_repeat_nums), no_repeat_nums)

```

对于一个非空字符串,判断是否可以由一个字字符串重复多次组成

```python
def get_item(a):
    for i in range(0, len(a)//2+1):
        s_list = a.split(a[:i+1])
        if len(set(s_list)) == 1:
            return True, a[:i+1]
    else: return False
get_item('aaaa')
```

如何查找一个字符串中特定的字符? find和index差异

```python
a= 'sldjgo3ergowje'
a.find('e')
a.index('e')
# find: 找到返回从0开始的下标值, 若找不到返回-1
# index: 类似字符串的find方法, 查找不到子串, 会抛出异常
```

压缩`aaabbcccd`为`a3b2c3d1`

```python
a = 'aaabbcccd'
b = []
for i in a:
    if i not in b:
        b.append(i)
        b.append(str(a.count(i)))
b
''.join(x for x in b)
```

'我是小明啊', 反转

```python
'我是小明啊'[::-1]
```

常用的字符串格式化方式

```python
name = 'hhm'
# 占位符
'hi %s'%name
# format
'hi {}'.format(name)
# f-string
f'hi {name}'
```

字符串驻留机制

```shell
- 短字符串赋值给多个对象时内存中只有一个副本,
- 长字符串不遵守驻留机制

驻留适用范围: 数字,字符和下划线组成的python标识符和整数\[-5, 256\]
```

## 文件操作

文件操作时, xreadlines和readlines区别

```shell
xreadlines: 返回迭代器, python2.3之后已不推荐, 直接使用for迭代文件对象
readlines: 把所有文件内容一次性读入内存, 返回列表
```

## 布尔值

列举布尔值为False的常见值

```shell
'', [], {}, None, 0, (), False
```

## Python底层基础

什么样的语言可以用装饰器

```python
# 函数可以当做参数传递
```

函数名字为何可调用

```python
# python中一切皆对象, 函数名指向函数的内存地址,也是一个对象
```

python函数调用参数传递方式是值传递还是引用传递

```python
# 不可变函数: 值传递
# 可变函数: 引用传递
# 其实都是引用传递
```

函数输出结果

```python
def add_end(l=[]):
    l.append("end")
    return l

print(add_end())
print(add_end())

# ['end']
# ['end', 'end'] 函数在定义阶段参数l就指向了[]的内存地址
```

python递归的最大层数

```python
# 998
```

以下代码输出结果

```python
x = 10
x += x
x -= x - x
x
```

```shell
is和==区别

- is: 内存地址ID是否相同
- ==: 值是否相同
```

可变类型和不可变类型

```shell
可变类型: 同一内存地址中的值可变, 字典, 集合, 列表
不可变类型: 同一内存地址中的值不变, 字符串, 数字, 元祖
```

按照执行效率高低排序

```python
def f1(lIn):
    l1 = sorted(lIn)
    l2 = [i for i in l1 if i<0.5]
    return [i*i for i in l2]

def f2(lIn):
    l1 = [i for i in l1 if i<0.5]
    l2 = sorted(l1)
    return [i*i for i in l2]

def f3(lIn):
    l1 = [i*i for i in lIn]
    l2 = sorted(l1)
    return [i for i in l1 if i<(0.5*0.5)]

import random
import cProfile
lIn = [random.random() for i in range(100000)]
cProfile.run('f1(lIn)')
cProfile.run('f2(lIn)')
cProfile.run('f3(lIn)')

# 执行效率: f2>f1>f3
```

浅拷贝与深拷贝

```python
# 浅拷贝: 仅仅拷贝第一层
# 深拷贝: 拷贝所有层
```

Python垃圾回收机制

```python
# 引用计数为主(有循环引用问题, 通过分代回收解决), 标记-清除为辅
```

获取Python解释器版本的方法

```python
import sys
sys.version
```

python哪个语句能直接显示的释放内存资源

```python
import gc
gc.collect()
```

## 集合

什么情况下, y != x-(x-y) 成立

```python
# x,y 是两个不相等的非空集合
x = set([1,2,3,4,5])
y = set([3,4,5,6,7,8,9])
x-(x-y)
```

## 字典

比较三者区别

```python
a = [1,2,3]
b = [(1), (2), (3)]
c = [(1,), (2,), (3,)]

# a和b两者值相等, a,b中元素都为数字, c为元祖
a == b
b == c
```

代码输出的结果

```python
v = dict.fromkeys(['k1','k2'],[])
v['k1'].append(666)
print(v)
v['k1'] = 777
print(v)

# k1, k2 指向同一个内存地址
# 赋值之后指向改变
```

按照字段value进行排序

```python
dict = {'a':24, 'g':52, 'i':12, 'k':33}
sorted(dict.items(), key=lambda x: x[1])
```

字典和json区别

```shell
字典: 一种数据结构, 字典的key必须可hash
json: 数据的一种表现形式, key必须是字符串, 必须用双引号
```

字典的数据有无先后排序

```shell
python3.6之后有序
```

字典推导式

```python
{k:v for k,v in enumerate(range(5)) }
```

dict的items()和iteritems()区别?

```shell
items(): 列表形式返回
iteritems(): 返回迭代器, python3用items()代替
```

## 列表

列表剔除重复之后的总和

```python
l = [3,4,1,2,5,6,6,5,4,3,3]

def single(l):
    res = 0
    for i in set(l):
        res += i
    return res

single(l)
```

输出结果

```python
arr = [1,2,3]
def bar():
    arr+=[5]

    bar()
print(arr)


# [1, 2, 3]
```

列表推导式和生成器表达式的输出结果

```python
[i % 2 for i in range(10)]
(i % 2 for i in range(10))

# 一个返回列表, 一个返回生成器
```

打乱一个排好序的list

```python
list = [1,2,3,4,5]
import random
random.shuffle(list)
list
```

按照age由大到小排序

```python
list = [{'name':'a', 'age':20},{'name':'b', 'age':30}, {'name':'c', 'age':35}]
sorted(list, key=lambda x: x['age'], reverse=True)
```

代码输出

```python
list  = [1,2,3,4]
list[6:]
```

列表生成式产生一个公差为11的等差数列

```python
list(range(1, 100, 11))
[x*11 for x in range(10)]
```

找出两个列表相同的元素和不同的元素

```python
a = [1,3,5,7,9]
b = [1,2,3,4,5]
set(a) & set(b)
set(a) ^ set(b)
```

删除list里面的重复元素

```python
a = [1,1,1,3,3,5,5,4,4,6,6,6,3,1,5,4,2]

sorted(set(a), key=a.index)

```

下面这段代码的输出

```python
def extendlist(val, list=[]):
    list.append(val)
    return list
list1 = extendlist(10)
list2 = extendlist(123, [])
list3 = extendlist('a')

print(list1, list2, list3)

# list1 : [10, 'a']
# list2 : [123]
# list3 : [10, 'a']
# 默认列表只有在函数定义的时候创建一次
```

对一个所有元素都是字符串的列表进行大小写无关的排序

```python
list = ['this', 'is', 'a', 'boy', '!']
sorted(list, key=lambda x: x.upper())
sorted(list)
```

列举字符串,列表,元祖,字典常用的5个方法

```python
# 字符串: split, upper, repalce, startswith, lower, join, strip, reverse
# 列表: append, pop, remove, del, index, count, sort
# 元祖: index, count, len, dir
# 字典 update, pop,  del, values, items, get, clear
```

## 面对对象

双下划线new和init区别

```python
'''
__init__是初始化方法，创建对象后，就立刻被默认调用了，可接收参数。

1、__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别

2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例

3、__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值

4、如果__new__创建的是当前类的实例，会自动调用__init__函数，通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。
'''
```

判断一个值是函数还是方法

```python
from types import MethodType, FunctionType
isinstance('a', FunctionType) # False
isinstance(lambda x: x, FunctionType) # True
isinstance(lambda x: x, MethodType) # False
```

面对对象的三大特性

```python
# 封装: 把一堆属性和方法放入一个容器中, 不关心具体实现, 通过.调用
# 继承: 子类可以继承父类的方法和属性, 包括使用和修改
# 多态: Python中指让多个类拥有相同的属性和方法, 统一命名规范, 提高开发者的代码统一性
```

鸭子类型

```python
# 当看到一只鸟走起来像鸭子,游泳起来像鸭子,叫起来也像鸭子,这只鸟就可以被称为鸭子
# 关注点在对象的行为,而不是类型
```

super的作用

```python
# 遵循类.mro(), 在子类中使用父类的属性,方法(既执行自己的同名方法, 也执行父类的同名方法)
```

mro

```python
# mro全称Method Resolution Order, 方法解析顺序
# 为方法调用提供搜索依据, 方法调用时就需要对当前类和基类进行搜索以确定方法所在的位置
```

c3算法

```python
'''
C3算法最早被提出是用于Lisp的，应用在Python中是为了解决原来基于深度优先搜索算法不满足本地优先级，和单调性的问题。
本地优先级：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。
单调性：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序。
'''
```

列举面对对象中的双下划线方法

```python
# __str__: 打印
# __init__: 初始化
# __new__: 创造对象
# __call__: 调用对象
# __setattr__: 添加/修改属性
# __getattr__: 使用.调用属性且属性不存在是触发
# __delattr__: 删除属性时触发

```

双下划线和单下划线区别

```python
# __a 私有属性,只有类对象自己能访问
# _a 只有类对象和子类对象能访问
```

实例变量和类变量

```python
# 实例变量 对象私有, 不影响其他对象
# 类变量 对象共有, 其中一个对象改变其值, 所以对象都会改变
```

静态方法和类方法

```python
# @classmethod 类方法:访问和修改类属性,进行类的相关操作,通过类或实例对象调用,传递cls
# @staticmethod 静态方法:不访问类属性和实例属性,通过类或实例对象调用,相当于普通函数
```

什么是反射

```python
# 用字符串的方式去访问对象的属性，调用对象的方法
# hasattr, getattr, setattr, delattr
```

hasattr(object, name), getattr, setattr

```python
# hasattr: 判断对象是否有name属性或者方法
class A():
    name = 'mike'
    def say(self):
        print(self.name)

a = A()
hasattr(AssertionError, 'name')
hasattr(AssertionError, 'say')
hasattr(AssertionError, 'sa')

# getattr: 获取对象属性或者方法
say = getattr(a, 'say')
say()

# setarrt: 赋值
setattr(a, 'age', 18)
a.age
```

## 匿名函数

lambda表达式格式以及应用场景

```python
# lambda 参数: 返回值
# 匿名函数, 不用定义函数, 只使用一次的场景
# 与函数有相同的作用域, 但引用计数为0, 使用一次就释放
list(filter(lambda x: x%2==0 ,[1,2,3,4,5,6]))
```

函数输出结果

```python
d = lambda p:p*2
t = lambda p:p*3

x = 2
x = d(x)
x = t(x)
x = d(x)
print(x)

# 24
```

函数输出结果

```python
def multipliers():
    return [lambda x:x*i for i in range(4)]

print([m(2) for m in multipliers()])
# [6, 6, 6, 6] 闭包函数延迟绑定问题

# 请修改 multipliers 的定义来产生期望的结果
def multipliers():
    return [lambda x, i=i:x*i for i in range(4)]
print([m(2) for m in multipliers()])
# [0, 2, 4, 6]
```

代码输出结果

```python
# 调用上下文如下
collapse = True
processFunc = collapse and (lambda s:" ".join(s.split())) or (lambda s:s)
print(processFunc("i\tam\ntest\tobject !"))

collapse = False
processFunc = collapse and (lambda s:" ".join(s.split())) or (lambda s:s)
print(processFunc("i\tam\ntest\tobject !"))

# i am test object !
# i am
# test object !
```

## 函数

如何在一个函数内部修改全局变量

```python
a = 1
def f():
    global a
    a = 2
f()
a
```

with statement语句的好处

```python
# 上下文管理器, 自动回收资源, 能在发生异常, return, break之前关闭文件
```

递归函数终止条件

```python
# 定义在递归函数内部, 做一个条件判断, 是否继续调用自身,还是return
```

回调函数如何通信

```python
# 回调函数是把函数的地址作为参数传递给另一个函数,将整个函数当做一个对象赋值给调用的函数
```

缺省参数

```python
# 缺省参数: 调用函数时如果没有传入参数,则调用默认的参数
```

pass作用

```python
# 站位, 不进行任何操作
```

写函数

```python
'''
有一个数据结构如下所示，请编写⼀个函数从该结构数据中返回由指定的字段和对应的值组成的字典。如果指定字段不存在，则跳过该字段。
'''
data:{
    "time":"2016-08-05T13:13:05",
    "some_id":"ID1234",
    "grp1":{"fld1":1, "fld2":2,},
    "xxx2":{"fld3":0, "fld4":0.4,},
    "fld6":11,
    "fld7": 7,
    "fld46":8
}

# fields:由"|"连接的以 fld 开头的字符串, 如 fld2|fld7|fld29

fields = 'fld2|fld3|fld7|fld19'
data = {
    "time":"2016-08-05T13:13:05",
    "some_id":"ID1234",
    "grp1":{"fld1":1, "fld2":2,},
    "xxx2":{"fld3":0, "fld4":0.4,},
    "fld6":11,
    "fld7": 7,
    "fld46":8
}

def select(data, fields):
    fields_list = fields.split('|')
    res = {}
    for k in data:
        if k in fields_list:
            res[k] = data[k]
        elif isinstance(data[k], dict):
            next_res = select(data[k], fields)
            res.update(next_res)
    return res

select(data, fields)
# {'fld2': 2, 'fld3': 0, 'fld7': 7}
```

函数输出结果

```python
def doff(arg1, *args):
    print(type(args))

doff("applea", "bananas", "cherry")

# <class 'tuple'>
```

全局变量引用

```python
k = 80
def f():
    global k
    print(k)
f()
```

函数转换为匿名函数

```python
def add(x, y):
    return x+y

lambda x,y: x+y
```

函数输出结果

```python
my_dict = {"a":0,"b":1}
def func(d):
    d["a"]=1
    return d

func(my_dict)
my_dict["c"]=2
print(my_dict)

# {'a': 1, 'b': 1, 'c': 2}
```

函数输出结果

```python
 # 有函数定义如下
def calc(a,b,c,d=1,e=2):
    return (a+b)*(c-d)+e

# 请分别写出以下标号代码的输出结果, 如果出错请写出 Error
print(calc(1,2,3,4,5)) # 2
print(calc(1,2,3)) # 8
print(calc(1,2)) #  missing 1 required positional argument: 'c'
print(calc(1,2,3,e=4)) # 10
print(calc(e=4, c=5, a=2,b=3)) # 24
print(calc(1,2,3, d=5, 4)) # SyntaxError
```

下列函数哪个输出1,2,3

```python
def func1():
    for i in range(3):
        print(i)
        a_list = [0, 1, 2]

    for i in a_list:
        print(i + 1)

def func2():
    i = 1

    while i < 3:
        print(i)

        i += 1

def func3():
    for i in range(3):
        print(i + 1)

# func3()
```

代码输出结果

```python
a = 1
def fun(a):
    a=2

fun(a)
print(a)

a = []
def fun(a):
    a.append(1)
fun(a)
print(a)

# 1
# [1]
```

打印结果为

```python
# 例 1
def func(a,b=[]):
    b.append(a)
    print(b)

func(1)
func(1)
func(1)
func(1)

# 例 2
def func(a,b={}):
    b[a] = 'v'
    print(b)
func(1)
func(2)

# [1]
# [1, 1]
# [1, 1, 1]
# [1, 1, 1, 1]

# {'1: "v", 2:"v"}
```

可变参数定义*args, **kwargs区别

```python
# *args: 位置参数, 1,2,3
# **kwargs: 关键字参数, a=1, b=2, c=3
def foo(*args, **kwargs):
    print("args=", args)
    print("kwargs=", kwargs)
    print("-----------------")

if __name__ == '__main__':
    foo(1, 2, 3, 4)
    foo(a=1, b=2, c=3)
    foo(1, 2, 3, 4, a=1, b=2, c=3)
    foo("a", 1, None, a=1, b='2', c=3)


args= (1, 2, 3, 4)
kwargs= {}
-----------------
args= ()
kwargs= {'a': 1, 'b': 2, 'c': 3}
-----------------
args= (1, 2, 3, 4)
kwargs= {'a': 1, 'b': 2, 'c': 3}
-----------------
args= ('a', 1, None)
kwargs= {'a': 1, 'b': '2', 'c': 3}
```

写一个base62encode函数, 62进制

```python
# 0123456789AB..Zab..z(10 个数字+26 个大写字母+26 个小写字母)

def base62Encode(n):
    s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    l = []
    while n>0:
        l.append(n%62)
        n = n // 62
    l = l[::-1]
    res = ''
    for i in l:
        res += s[i]
    return res

base62Encode(12)
```

## 其他

一行代码实现1-100的和

```python
sum(range(1, 101))
```

一行代码实现99乘法表

```python
print('\n'.join(['\t'.join([f'{i}*{j}={i*j}' for i in range(1, j+1)]) for j in range(1, 10)]))
```

`1 < (2 == 2)`和`1 < 2 == 2`的结果分别是什么

```python
1 < 2 == 2
# True
1 < (2 == 2)
```

python一行print1到100的偶数

```python
print([x for x in range(101) if x%2==0 ])
print(list(filter(lambda x:x%2==0, range(101))))
```

完数:一个数等于它的因子之和, 如6=1+2+3, 找出1000以内的所有完数

```python
for i in range(1, 1000):
    sum = 0
    for j in range(1, i//2+1):
        if i%j==0:
            sum+=j
    if sum==i:
        print(i)
```

## 模块使用

常用模块

```python
# os,sys,time,datetime,json,pickle,random,hashlib,re,math,logging
# requests,BeautifulSoup,xpath,gevent,asyncio,twisted, scrapy, pymysql
# pandas,numpy,scipy,matplotlib,seaborn
```

json序列化可以处理的数据类型, 以及处理datetime类型

```python
# 可以处理的数据类型: bool(true, false), None(null), str, int, list(array), dict(object)

import json
from datetime import datetime, date

class JsonCustomEncode(json.JSONEncoder):
        def default(self, o):
            if isinstance(o, datetime):
                return o.strftime('%Y-%m-%d %H:%M:%S')
            elif isinstance(o, date):
                return o.strftime('%Y-%m-%d')
            else:
                return super().default(o)

json.dumps(datetime.now(), ensure_ascii=False, cls=JsonCustomEncode)
```

查看一个目录下的所有文件

```python
import os
os.listdir(path)
```

判断一个邮箱是否合法

```python
import re

if re.match(r'^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$', email):
    print('right')
else:
    print('wrong')
```

添加路径到Python环境变量

```python
import sys
sys.path.append(path)
```

爬虫用到的模块

```python
# requests 请求库
# BeautifulSoup 解析库
# selenium 自动化测试工具
# pyquery 网页解析库
# pymysql 操作mysql数据库
# pymongo 操作mongodb数据库
# Scrapy 异步爬虫框架
```

判断今天是今年的第几天

```python
import datetime
datetime.datetime.now().date() - datetime.date(2019, 12, 31)
```

从0-99随机取出10个, 不能重复

```python
import random
a = set()

while len(a)<11:
    a.add(random.randint(0, 99))
a
```

map和reduce

```python
# map: 将传入的函数依次作用到序列的每个函数
# reduce: 累积计算

list(map(lambda x: x*2, range(5)))
from functools import reduce
reduce(lambda x,y: x+y, range(5))
```

enumerate用法

```python
for index, key in enumerate(range(1, 9)):
    print(index, key)
```

列举常见的内置函数

```python
# sorted() len() divmode() range()
# int() str() list() dict() set() chr() ord()
# exec() filter() type() id() isinstance() reversed()
```

filter, map, reduce用法

```python
a = [1,2,3,4,5]
list(filter(lambda x: x%2==0, a))
list(map(lambda x, y: x+y, a, a))
reduce(lambda x,y: x+y+1, a)
```

输出结果

```python
list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))

# ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

代码输出结果

```python
nums = range(2,20)
for i in nums:
    nums = filter(lambda x:x==i or x % i, nums)
print(list(nums))

# [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
```

## 异常捕获

输出结果

```python
def test():
    try:
        raise ValueError("something wrong")
    except ValueError as e:
        print("Error occurred")
        return
    finally:
        print("Done")

test()

# Error occurred
# Done
```

python如何捕获异常

```python
try:
    raise KeyError()
except KeyError:
    print('error')
else:
    print('not error')
finally:
    print('finally')
```

## 闭包与装饰器

什么是闭包

```python
# 内部函数引用外部函数的变量
```

实现一个装饰器, 控制函数调用频率, 如10秒一次

```python
import time
last_time = 0
def throttle(func):
    def wrapper(*args, **kwargs):
        global last_time
        if time.time()-last_time>9:
            res = func(*args, **kwargs)
            time.sleep(1)
            last_time = time.time()
            return res
    return wrapper

@throttle
def f():
    print('f')

for i in range(5):
    f()
```

实现一个装饰器, 调用函数一次执行五次

```python
def throttle(func):
    def inner(*args, **kwargs):
        l = []
        for i in range(5):
            res = func(*args, **kwargs)
            l.append(res)
        return l
    return inner

@throttle
def f():
    return 3

f()
```

输出结果

```python
def say_hi(func):
    def wrapper(*args, **kwargs):
        print("HI")
        ret = func(*args, **kwargs)
        print("BYE")
        return ret
    return wrapper

def say_yo(func):
    def wrapper(*args, **kwargs):
        print("YO")
        return func(*args, **kwargs)
    return wrapper

@say_hi
@say_yo
def func():
    print("ROCK & ROLL")
func()

# HI
# YO
# ROCK & ROLL
# BYE
```

标准库中functools.wraps的作用

```python
# 保留原函数名称和docstring
from functools import wraps

def wrapper(func):
    @wraps(func)
    def inner(*args, **kwargs):
        return funct(*args, **kwargs)
    return inner

@wrapper
def f():
    """
    function f
    """
    pass

print(f)
help(f)

    <function f at 0x0000022630832168>
    Help on function f in module __main__:
    f()
        function f
```

## 生成器

使用生成器编写fib函数

```python
def fib():
    i, j = 0, 1
    while True:
        k = i + j
        yield k
        i = j
        j = k
for fn in fib():
    if fn > 1000:
        break
    else:
        print(fn)
```

解释生成器和函数的区别, 实现和简单使用generator

```python
# 生成器: yield value 保持程序运行状态
# 函数: return value
```

yield和yield from

```python
# yield: 函数中有yield则为生成器, 可用for或者next迭代
# yield from: 返回另外一个生成器
```

函数输出结果

```python
a = 10
b = [1,2]
c = [a, b]
a = 15
b[0] = 3
print(c)

# [10, [3, 2]]
```

代码输出结果

```python
class Parent:
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass

print(Parent.x, Child1.x, Child2.x)
Child1.x = 2
print(Parent.x, Child1.x, Child2.x)
Child1.x = 3
print(Parent.x, Child1.x, Child2.x)

# 1 1 1
# 1 2 1
# 1 3 1
```

## 网络相关

常见的tcp flags

```python
# syn rst ack urg
```

tracerroute使用的网络协议

```python
# ICMP
```

iptables规则

```python
'''
A.屏蔽192.168.1.5访问本机dns服务端口
B.允许10.1..0/2访问本机的udp88889999端口
iptables -A INPUT -p ICMP --icmp-type 8 -m time --timestart 00:00:00 --timestop 23:59:59 --weekdays Mon -j DROP
'''
```

什么是CDN

```python
# 内容分发网络, 目的是使用户可以就近到服务器取得所需内容，解决网络拥挤的状况，提高用户访问网站的响应速度。
```

python的底层网络交互模块

```python
request, urllib, socket, pycurl, urllib3
```

OSI七层模型

```python
# 应用层 ftp, nfs, http
# 表示层 telnet, snmp
# 会话层 smtp, dns
# 传输层 tcp, udp
# 网络层 ip, icmp, arp
# 数据链路层 ppp, pdn, slip, fddi, ethernet
# 物理层 mac地址
```

b/s和c/s架构

```python
'''
b/s 浏览器, 服务器, 网站
c/s 客户端, 服务端, qq, mysql

C/S :优点:交互性好,对服务器压力小,安全 ;缺点:服务器更新时需要同步更新客户端
B/S:优点:不需要更新客户端   缺点:交互性差,安全性低
'''
```

TCP三次握手

```python
'''
客户端发送报文, 带有SYN标志, 以及随机生成的序号100(0字节)
服务端接收到报文后返回报文, SYN200(0字节), ACK101(字节+1)
客户端再次发送报文, ACK201
三次握手结束, 客户端开始向服务端发送数据
'''
```

TCP四次挥手

```python
'''
TCP连接是双向通信(双全工), 每个方向必须单独进行关闭
四次挥手过程, 客户端和服务端都可以先开始断开连接

客户端发送报文请求通信关闭, 报文带FIN标识
服务端接收到之后返回ACK, 答应关闭连接请求
服务端发送报文请求通信关闭, 报文带FIN标识
客户端接收到之后返回ACK, 答应关闭连接请求
'''
```

arp协议

```python
# 地址解析协议, 使用ARP协议可实现通过IP地址获得对应主机的物理地址(MAC地址)
```

TCP和UDP区别

```python
'''
1、TCP面向连接;UDP是无连接的,即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
'''

# 为何基于tcp协议的通信比基于udp协议的通信更可靠？
'''
tcp:可靠 对方给了确认收到信息，才发下一个，如果没收到确认信息就重发
udp:不可靠 一直发数据，不需要对方回应
'''
```

局域网和广域网

```python
'''
两者范围不一样:
    局域网就是在固定的一个地理区域内由2台以上的电脑用网线和其他网络设备搭建而成的一个封闭的计算机组，范围在几千米以内；
    广域网是一种地域跨度非常大的网络集合，范围在几十公里到几千公里。

两者的IP地址设置不一样:
    局域网里面，必须在网络上有一个唯一的IP地址，这个IP地址是唯一的，在另外一个局域网，这个IP地址仍然能够使用。
    广域网上的每一台电脑（或其他网络设备）都有一个或多个广域网IP地址，而且不能重复。
'''
```

socket, 简述基于tcp协议的套接字通信流程

```python
'''
Socket: 应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。

服务端: 创建socket对象，绑定ip端口bind(),  设置最大链接数listen(),  accept()与客户端的connect()创建双向管道， send(), recv(),close()

客户端: 创建socket对象，connect()与服务端accept()创建双向管道, send(),recv(),close()
'''
```

什么是粘包

```python
'''
数据粘在一起，主要因为：接收方不知道消息之间的界限，不知道一次性提取多少字节的数据造成的数据量比较小，时间间隔比较短，就合并成了一个包，这是底层的一个优化算法（Nagle算法）
'''
```

IO多路复用

```python
# I/O多路复用是用于提升效率, 单个进程可以同时监听多个网络连接IO。
# 通过一种机制，可以监视多个文件描述符，一旦描述符就绪（读就绪和写就绪），能通知程序进行相应的读写操作，I/O多路复用避免阻塞在io上，原本为多进程或多线程来接收多个连接的消息变为单进程或单线程保存多个socket的状态后轮询处理。
```

什么是防火墙

```python
'''
在互联网上防火墙是一种非常有效的网络安全模型，通过它可以隔离风险区域(即Internet或有一定风险的网络)与安全区域(局域网)的连接，同时不会妨碍人们对风险区域的访问。所以它一般连接在核心交换机与外网之间。

1.过滤进出网络的数据
2.管理进出访问网络的行为
3.封堵某些禁止业务
4.记录通过防火墙信息内容和活动
5.对网络攻击检测和告警
'''
```

路由器和交换机

```python
'''
1：交换机：是负责内网里面的数据传递（arp协议）根据MAC地址寻址。
   路由器：在网络层，路由器根据路由表，寻找该ip的网段。
2：路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。
   交换机可以把很多主机连起来，这些主机对外各有各的IP。
3：交换机是做端口扩展的，也就是让局域网可以连进来更多的电脑。
   路由器是用来做网络连接，也就是连接不同的网络。
'''

```

什么是域名解析

```python
'''
在互联网上，所有的地址都是ip地址，现阶段主要是IPv4（比如：110.110.110.110）。
但是这些ip地址太难记了，所以就出现了域名（比如http://baidu.com）。
域名解析就是将域名，转换为ip地址的这样一种行为。
'''
```

如何修改本地host地址

```python
'''
Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”
当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，
一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交给DNS域名解析服务器进行IP地址的解析。

文件路径：C:\WINDOWS\system32\drivers\etc
将127.0.0.1   www.163.com  添加在最下面
修改后用浏览器访问“www.163.com”会被解析到127.0.0.1，导致无法显示该网页。
'''
```

select, epoll, poll

```python
'''
I/O多路复用的本质就是用select/poll/epoll，去监听多个socket对象，如果其中的socket对象有变化，用户进程就知道了。

select是不断轮询去监听的socket，socket个数有限制，一般为1024个；

poll还是采用轮询方式监听，只不过没有个数限制；

epoll并不是采用轮询方式去监听了，而是当socket有变化时通过回调的方式主动告知用户进程。
'''
```

LVS

```python
'''
LVS ：Linux虚拟服务器
作用：LVS主要用于多服务器的负载均衡。
它工作在网络层，可以实现高性能，高可用的服务器集群技术。
它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。
它易用，配置非常简单，且有多种负载均衡的方法。
它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。另外可扩展性也非常好。
'''
```

Nginx

```python
# Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器
# 同时也是一个IMAP、POP3、SMTP代理服务器。可以用作HTTP服务器、方向代理服务器、负载均衡。
```

Keepalived

```python
'''
    Keepalived起初是为LVS设计的，专门用来监控集群系统中各个服务节点的状态，它根据TCP/IP参考模型的第三、第四层、第五层交换机制检测每个服务节点的状态，如果某个服务器节点出现异常，或者工作出现故障，Keepalived将检测到，并将出现的故障的服务器节点从集群系统中剔除，这些工作全部是自动完成的，不需要人工干涉，需要人工完成的只是修复出现故障的服务节点。

    后来Keepalived又加入了VRRP的功能，VRRP（Vritrual Router Redundancy Protocol,虚拟路由冗余协议)出现的目的是解决静态路由出现的单点故障问题，通过VRRP可以实现网络不间断稳定运行，因此Keepalvied 一方面具有服务器状态检测和故障隔离功能，另外一方面也有HA cluster功能。
'''
```

HAProxy

```python
'''
- TCP 代理：可从监听 socket 接受 TCP 连接，然后自己连接到 server，HAProxy 将这些 sockets attach 到一起，使通信流量可双向流动。

- HTTP 反向代理（在 HTTP 专用术语中，称为 gateway）：HAProxy 自身表现得就像一个 server，通过监听 socket 接受 HTTP 请求，然后与后端服务器建立连接，通过连接将请求转发给后端服务器。

- SSL terminator / initiator / offloader: 客户端 -> HAProxy 的连接，以及 HAProxy -> server 端的连接都可以使用 SSL/TLS

- TCP normalizer: 因为连接在本地操作系统处终结，client 和 server 端没有关联，所以不正常的 traffic 如 invalid packets, flag combinations, window advertisements, sequence numbers, incomplete connections(SYN floods) 不会传递给 server 端。这种机制可以保护脆弱的 TCP stacks 免遭协议上的攻击，也使得我们不必修改 server 端的 TCP 协议栈设置就可以优化与 client 的连接参数。


- HTTP normalizer: HAProxy 配置为 HTTP 模式时，只允许有效的完整的请求转发给后端。这样可以使得后端免遭 protocol-based 攻击。一些不规范的定义也被修改，以免在 server 端造成问题（eg: multiple-line headers，会被合并为一行）

- HTTP 修正工具：HAProxy 可以 modify / fix / add / remove / rewrite URL 及任何 request or response header。

- a content-based switch: 可基于内容进行转发。可基于请求中的任何元素转发请求或连接。因此可基于一个端口处理多种协议（http,https, ssh）

- a server load balancer: 可对 TCP 连接 和 HTTP 请求进行负载均衡调度。工作于 TCP 模式时，可对整个连接进行负载均衡调度；工作于 HTTP 模式时，可对 HTTP 请求进行调度。

- a traffic regulator: 可在不同的方面对流量进行限制，保护 server ，使其不超负荷，基于内容调整 traffic 优先级，甚至可以通过 marking packets 将这些信息传递给下层以及网络组件。

- 防御 DDos 攻击及 service abuse: HAProxy 可为每个 IP地址，URL，cookie 等维护大量的统计信息，并对其进行检测，当发生服务滥用的情况，采取一定的措施如：slow down the offenders, block them, send them to outdated contents, etc

- 是 network 的诊断的一个观察节点：根据精确记录细节丰富的日志，对网络诊断很有帮助

- an HTTP compression offloader：可自行对响应进行压缩，而不是让 server 进行压缩，因此对于连接性能较差的 client，或使用高延迟移动网络的 client，可减少页面加载时间。
'''
```

负载均衡

```python
'''
系统的扩展可分为纵向（垂直）扩展和横向（水平）扩展。纵向扩展，是从单机的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。这就是典型的集群和负载均衡架构
'''
```

rpc

```python
# RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。
# HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等...

```

TCP优缺点

```python
'''
优点：TCP在数据传递时，有确认、窗口、重传、阻塞等控制机制，能保证数据正确性，较为可靠。
缺点：TCP相对于UDP速度慢一点，要求系统资源较多。
'''
```

浏览器通过WSGI请求动态资源过程

```python
'''
1.发送http请求动态资源给web服务器
2.web服务器收到请求后通过WSGI调用一个属性给应用程序框架
3.应用程序框架通过引用WSGI调用web服务器的方法，设置返回的状态和头信息。
4.调用后返回，此时web服务器保存了刚刚设置的信息
5.应用程序框架查询数据库，生成动态页面的body的信息
6.把生成的body信息返回给web服务器
7.web服务器吧数据返回给浏览器
'''
```

浏览器访问网站的过程

```python
'''
先要解析出baidu.com对应的ip地址
- 要先使用arp获取默认网关的mac地址
- 组织数据发送给默认网关(ip还是dns服务器的ip，但是mac地址是默认网关的mac地址)
- 默认网关拥有转发数据的能力，把数据转发给路由器
- 路由器根据自己的路由协议，来选择一个合适的较快的路径转发数据给目的网关
- 目的网关(dns服务器所在的网关)，把数据转发给dns服务器
- dns服务器查询解析出baidu.com对应的ip地址，并原路返回请求这个域名的client
得到了baidu.com对应的ip地址之后，会发送tcp的3次握手，进行连接
使用http协议发送请求数据给web服务器
- web服务器收到数据请求之后，通过查询自己的服务器得到相应的结果，原路返回给浏览器。
- 浏览器接收到数据之后通过浏览器自己的渲染功能来显示这个网页。
- 浏览器关闭tcp连接，即4次挥手结束，完成整个访问过程
'''
```

get和post的区别

```python
'''
get
请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&连接。URL的
编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。

POST
请求会把请求的数据放置在HTTP请求包的包体中因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。

传输数据的大小：
- 在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对
于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会
受到URL长度的限制。
- 对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST
提交数据大小进行限制，Apache、IIS都有各自的配置。
安全性：
- POST的安全性比GET的高。这里的安全是指真正的安全，而不同于上面GET提到的安全方法
中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过GET请求，
用户名和密码都会暴露再URL上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的
历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET请求提交的数据
还可能会造成Cross-site request frogery攻击。

get比post效率高

POST请求的过程：
  1.浏览器请求tcp连接（第一次握手）
  2.服务器答应进行tcp连接（第二次握手）
  3.浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行
第一次数据发送）
  4.服务器返回100 continue响应
  5.浏览器开始发送数据
  6.服务器返回200 ok响应

GET请求的过程：
    1.浏览器请求tcp连接（第一次握手）
    2.服务器答应进行tcp连接（第二次握手）
    3.浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时
进行第一次数据发送）
    4.服务器返回200 OK响应
'''
```

cookie和session

```python
'''
1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗考虑到安全应当使
用session。
3、session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能考虑到减轻服
务器性能方面，应当使用cookie。
4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
5、建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在cookie中
'''
```

http状态协议码

```python
'''
通过状态码告诉客户端服务器的执行状态，以判断下一步该执行什么操作。
常见的状态机器码有：
100-199：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。
200-299：表示服务器成功接收请求并已完成处理过程，常用200（OK请求成功）。
300-399：为完成请求，客户需要进一步细化请求。302（所有请求页面已经临时转移到新的url）。
 304、307（使用缓存资源）。
400-499：客户端请求有错误，常用404（服务器无法找到被请求页面），403（服务器拒绝访问，
权限不够）。
500-599：服务器端出现错误，常用500（请求未完成，服务器遇到不可预知的情况）。
'''
```

tcp的2msl

```python
'''
主动发送fin关闭的一方，在4次挥手最后一次要等待一段时间我们称这段时间为2MSL
TIME_WAIT状态的存在有两个理由：
1.让4次挥手关闭流程更加可靠
2.防止丢包后对后续新建的正常连接的传输造成破坏
'''
```

为什么客户端在time_wait状态必须等待2msl的时间

```python
'''
1、为了保证客户端发送的最后一个ACK报文段能够达到服务器。 这个ACK报文段可能丢失，
因而使处在LAST-ACK状态的服务器收不到确认。服务器会超时重传FIN+ACK报文段，客户端就
能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重启计时器。最
好，客户端和服务器都正常进入到CLOSED状态。如果客户端在TIME-WAIT状态不等待一段时间，
而是再发送完ACK报文后立即释放连接，那么就无法收到服务器重传的FIN+ACK报文段，因而也
不会再发送一次确认报文。这样，服务器就无法按照正常步骤进入CLOSED状态。
2、防止已失效的连接请求报文段出现在本连接中。客户端在发送完最后一个ACK确认报文段
后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样
就可以使下一个新的连接中不会出现这种旧的连接请求报文段。
'''
```

http和https的区别

```python
'''
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安
全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于
对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协
议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。
HTTPS和HTTP的区别主要如下：
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、
身份认证的网络协议，比http协议安全。
'''
```

http协议以及协议头部中表示数据类型的字段

```python
'''
HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网
（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。
HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件， 图片文件， 查询结果等）。

HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体
信息系统。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW 中
使用的是 HTTP/1.0 的第六版，HTTP/1.1 的规范化工作正在进行之中，而且 HTTP-NG(Next
Generation of HTTP)的建议已经提出。
HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过URL 向 HTTP 服
务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。
表示数据类型字段： Content-Type
'''
```

http请求方法

```python
'''
根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法： GET， POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS， PUT， DELETE， TRACE 和 CONNECT 方法。
1、 GET 请求指定的页面信息，并返回实体主体。
2、HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
3、POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在
请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
4、PUT 从客户端向服务器传送的数据取代指定的文档的内容。
5、DELETE 请求服务器删除指定的页面。
6、CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
7、OPTIONS 允许客户端查看服务器的性能。
8、TRACE 回显服务器收到的请求，主要用于测试或诊断。
'''
```

使用socket套接字需要传入哪些参数

```python
'''
Address Family 和 Type，分别表示套接字应用场景和类型。
family的值可以是AF_UNIX(Unix域，用于同一台机器上的进程间通讯)，也可以是AF_INET
（对于IPV4协议的TCP和 UDP），至于type参数，SOCK_STREAM（流套接字）或者
SOCK_DGRAM（数据报文套接字）,SOCK_RAW（raw套接字）。
'''
```

http常见请求头

```python
'''
Host (主机和端口号)
Connection (链接类型)
Upgrade-Insecure-Requests (升级为 HTTPS 请求)
User-Agent (浏览器名称)
Accept (传输文件类型)
Referer (页面跳转处)
Accept-Encoding（文件编解码格式）
Cookie （Cookie）
x-requested-with :XMLHttpRequest  (是 Ajax 异步请求)
'''
```

url的形式

```python
'''
形式： scheme://host[:port#]/path/…/[?query-string][#anchor]
scheme：协议(例如：http， https， ftp)
host：服务器的IP地址或者域名
port：服务器的端口（如果是走协议默认端口，80 or 443）
path：访问资源的路径
query-string：参数，发送给http服务器的数据
anchor：锚（跳转到网页的指定锚点位置）
http://localhost:8000/file/part01/1.2.html
'''
```

## 多进程多线程携程

进程, 线程, 携程

```python
'''
1.进程是操作系统资源分配的最小单位，拥有独立的资源和地址空间
2.线程是CPU调度的单位
3.同一进程中的线程是资源共享的。
4.协程是用户级别的，程序之间的切换由用户自行处理，节省了CPU的调度时间。
'''
```

GIL

```python
# 全局解释锁，每次只能一个线程获得cpu的使用权：
# 线程之间的数据是共享的,为了线程安全,也就是为了解决多线程之间的数据完整性和状态同步而加的锁。
```

进程池和线程池

```python
from concurrent.futures import ThreadPoolExecutor

def task(i):
    print(f'{i} do something')
    return i*2

def callback(res):
    print(res.result())

if __name__ == '__main__':
    executor = ThreadPoolExecutor(max_workers=5)
    for i in range(20):
        executor.submit(task, i).add_done_callback(callback)

    executor.shutdown()
```

threading.local作用

```python
# 为每个线程创建一个独立的空间，使得线程对自己的空间中的数据进行操作（数据隔离）。
import threading
from threading import local

obj = local()

def task(i):
    obj.xxxxx = i
    print(obj.xxxxx,i)

for i in range(10):
    t = threading.Thread(target=task,args=(i,))
    t.start()
```

进程间如何进行通信

```python
# python提供了多种进程通信的方式，主要Queue和Pipe这两种方式，Queue用于多个进程间实现通信，Pipe是两个进程的通信。

# PIPE
import multiprocessing
import os,time,random

#写数据进程执行的代码
def proc_send(pipe,urls):
    for url in urls:
        print('Process is send :%s' %url)
        pipe.send(url)
        time.sleep(random.random())

#读数据进程的代码
def proc_recv(pipe):
    while True:
        print('Process rev:%s' %pipe.recv())
        time.sleep(random.random())

if __name__ == '__main__':
    #父进程创建pipe，并传给各个子进程
    pipe = multiprocessing.Pipe()
    p1 = multiprocessing.Process(target=proc_send,args=(pipe[0],['url_'+str(i) for i in range(10) ]))
    p2 = multiprocessing.Process(target=proc_recv,args=(pipe[1],))
    #启动子进程，写入
    p1.start()
    p2.start()

    p1.join()
    p2.terminate()

```

并发和并行

```python
# 并发：同一时刻只能处理一个任务, 但可以交替处理多个任务,(一个处理器同时处理多个任务)
# 并行：同一时刻可以处理多个任务, (多个处理器或者是多核的处理器同时处理多个不同的任务)
```

同步和异步, 阻塞和非阻塞

```python
'''
同步：多个任务之间有先后顺序执行，一个执行完下个才能执行。
异步：多个任务之间没有先后顺序，可以同时执行有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！
阻塞：如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。
非阻塞：如果不会卡住，可以继续执行，就是说非阻塞的。
同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。
'''
```

生产者消费者模型应用场景

```python
'''
生产者与消费者模式是通过一个容器来解决生产者与消费者的强耦合关系，生产者与消费者之间不直接进行通讯，
而是利用阻塞队列来进行通讯，生产者生成数据后直接丢给阻塞队列，消费者需要数据则从阻塞队列获取，
实际应用中，生产者与消费者模式则主要解决生产者与消费者的生产与消费的速率不一致的问题，达到平衡生产者与消费者的处理能力，而阻塞队列则相当于缓冲区。

应用场景：用户提交订单，订单进入引擎的阻塞队列中，由专门的线程从阻塞队列中获取数据并处理。

优势：
1；解耦
假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。
将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。
2：支持并发
生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只能一直等着
而使用这个模型，生产者把制造出来的数据只需要放在缓冲区即可，不需要等待消费者来取。
3：支持忙闲不均
缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。
当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。
'''
```

使用多进程和进程池的方式读取文件

```python
# 多进程
"""通过多进程加速读取excel的测试"""
__author__ = "hanyaning@deri.energy"
import os.path
import time
from service import logger
import pandas as pd
from multiprocessing import Process, Manager
startTime = time.time()

logger = logger.MyLogger("multi_process").getLogger()


def getExcelData(path, return_data=None, file_name=""):
    global startTime
    logger.info("开始读取Excel文件，当前进程pid：" + str(os.getpid()))
    if not os.path.exists(path):
        raise FileNotFoundError()
    if os.path.isfile(path):
        return_data[file_name] = pd.read_excel(path, skiprows=1, skipfooter=1)
        logger.info("读取Excel文件完毕，当前进程pid：" + str(os.getpid()))

if __name__ == "__main__":
    excel_path = os.path.join(os.getcwd(), "../excels")
    xls_names = [x for x in os.listdir(excel_path) if x.endswith(".xls")]
    first = str(time.time() - startTime)
    logger.info("进入程序用时：" + first)
    p_list = []
    # Manager类似于同步数据管理工具，可在多进程时实现各进程操作同一个数据，比如这里通过它组织返回值
    manager = Manager()
    # Manager.dict()类似于共享变量，各个进程可以修改它，通过每次添加不同的key值，可以实现方法返回值的获取
    return_data = manager.dict()
    first = time.time() - startTime
    # 手动创建多个进程读取，可能存在创建进程过多导致系统崩溃的情况
    for file_name in xls_names:
        p = Process(target=getExcelData, args=(os.path.join(excel_path, file_name), return_data, file_name))
        p.start()
        p_list.append(p)
    print(p_list)

    """
    经测试，直到这里都还会延迟数秒才执行进程的target方法，尽管前面已经调用了start(),但进程并没有立即执行
    寡人认为是系统创建进程需要时间，并且是创建好所有进程后才各进程才开始工作，这里要创建120个进程花费了大多数的时间
    后面在采用进程池时，当设置最大进程数为120时，依然花费了大把的时间，而设置为10时，大大缩小了创建进程到执行target方法所要等待的时间
    这也证明了寡人的观点，至于正确与否，寡人先跟代码去了，且等下回分解
    """
    for p in p_list:
        # 如果有子进程没有执行完，需要先阻塞主进程
        p.join()
    logger.info("各进程执行完毕")
    # 获取返回值字典为列表
    data_frames = return_data.values()
    # 合并列表为一个dataFrame
    data = pd.DataFrame()

    for da in data_frames:
        data = data.append(da)

    endTime = time.time()
    print(endTime - startTime)
    print(len(data))


# 进程池
"""通过多进程加速读取excel的测试"""
__author__ = "hanyaning@deri.energy"
import os.path
import time
from service import logger
import pandas as pd
from multiprocessing import Pool

logger = logger.MyLogger("multi_process").getLogger()


def getExcelData(path):
    logger.info("开始读取excel，当前进程pid：" + str(os.getpid()))
    data = pd.DataFrame()
    if not os.path.exists(path):
        raise FileNotFoundError()
    if os.path.isfile(path):
        logger.info("读取Excel文件完毕，当前进程pid：" + str(os.getpid()))
    return data.append(pd.read_excel(path, skiprows=1, skipfooter=1), sort=False)


if __name__ == "__main__":
    excel_path = os.path.join(os.getcwd(), "../excels")
    xls_names = [x for x in os.listdir(excel_path) if x.endswith(".xls")]
    startTime = time.time()

    p_list = []
    # 使用进程池Pool
    pool = Pool(processes=10)
    pool_data_list = []
    data = pd.DataFrame()
    for file_name in xls_names:
        # 需要注意不能直接在这里调用get方法获取数据,原因是apply_async后面 get()等待线程运行结束才会下一个,这里多进程会变成阻塞执行
        pool_data_list.append(pool.apply_async(getExcelData, (os.path.join(excel_path, file_name),)))
    pool.close()
    # 需要阻塞以下，等所有子进程执行完毕后主线程才继续执行
    pool.join()
    for pool_data in pool_data_list:
        # 这里再使用get()方法可以获取返回值
        data = data.append(pool_data.get())
    endTime = time.time()
    print(endTime - startTime)
    print(len(data))

```

实现一个简单的socket编程

多线程多进程何时适用

```python
# cpu密集型用多进程
# IO密集型用多线程
```

多进程中join和deamon的区别

```python
# join 阻塞主进程, 直到子进程运行完毕
# deamon 守护进程, 不能创建子进程, 所有非守护进程运行完毕后,被主进程回收
```

GIL对Python性能的影响

```python
# 同一时间只能有一个线程获得CPU的执行权限, Python并没有真正的实现多线程
'''
GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行字节码。
线程释放GIL锁的情况：
在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL
Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100
Python使用多进程是可以利用多核的CPU资源的。
多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁
'''
```

线程, 进程使用场景

```python
# 高并发的服务端代码, 高性能的爬虫
```

使用yield实现一个携程

```python
import time

def consumer():
    while True:
        food = yield
        print(f'eating {food}')

def producer(c):
    c.__next__()
    for i in range(5):
        c.send(i)

c = consumer()
producer(c)

```

使用async实现一个携程

```python
import asyncio
from datetime import datetime

async def f():
    print(f"start: {datetime.now()}")
    await asyncio.sleep(3)
    print(f"end: {datetime.now()}")

loop = asyncio.get_event_loop()
tasks = [f(), f()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
```

asyncio

```python
# python高并发模块
```

如何避免线程死锁

```python
# 1.加锁顺序（线程按照一定的顺序加锁）
# 2.加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
# 3.死锁检测
```

gevent

```python
'''
gevent是第三方库，通过greenlet实现协程，其基本思想是：
当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。
'''
```

twisted

```python
# twisted是异步非阻塞框架, 爬虫框架Scrapy依赖twisted
```

什么是锁, 有几种

```python
# 锁(Lock)是 Python 提供的对线程控制的对象, 有互斥锁, 递归锁
```

什么是死锁

```python
'''
若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。
GIL锁 全局解释器锁（只在cpython里才有）
作用：限制多线程同时执行，保证同一时间只有一个线程执行，所以cpython里的多线程其实是伪多线程!
所以Python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程，
进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作才会切换。
三者的关系：进程里有线程，线程里有协程。
'''
```

什么是线程安全, 互斥锁

```python
'''
每个对象都对应于一个可称为" 互斥锁"的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
同一个进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，
另一个线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。
'''
```

什么是孤儿进程和僵尸进程

```python
'''
孤儿进程：父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被 init 进程(进程号为 1)所收养，并由init进程对它们完成状态收集工作。

僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用 wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。

避免僵尸进程的方法：
-fork两次用孙子进程去完成子进程的任务；
-用wait()函数使父进程阻塞；
-使用信号量，在 signal handler 中调用waitpid，这样父进程不用阻塞。
'''
```

使用udp发送, 接收数据

```python
import socket

udp_client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udp_client.sendto('hi'.encode('utf-8'), ('127.0.0.1', 8000))
data, addr = udp_client.recvfrom(1024)
udp_client.close()
```

删除一个文件

```python
import os
os.remove('./a.txt')
```

## 日志

logging模块

```python

"""
在我们平时编写的程序，基本上都会有记录日志的需求，并且日志当中包含的内容既有正常的程序访问，又有错误，警告等信息输出，在python的logging模块当中就提供了标准的日志接口，可以通过它来存储各种格式的日志.
logging模块也分为五个等级：
debug(),
info(),
warning(),
error(),
critical()
其中默认级别为warning，默认打印到终端

开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试；应用上线或部署生产环境时，应该使用WARNING或ERROR或CRITICAL级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。
"""
```

列表去重

```python
l = [2,3,4,5,1,2,2,3,3,4,4,5,6,7,7]
# 无序去重
list(set(l))

# 有序去重
new_l = []
for i in l:
    if i not in new_l:
        new_l.append(i)
new_l
```

python生成随机小数,整数, 0-1随机小数

```python
'''
随机整数：random.randint(a,b),生成区间内的整数

随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数

0-1随机小数：random.random(),括号中不传参
'''
```
