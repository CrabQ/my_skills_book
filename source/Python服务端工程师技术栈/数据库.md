# 数据库

## Mysql基础

### 什么是事务

Transaction

    事务是数据库并发控制的基本单位
    事务可以看做是一系列SQL语句的集合
    事务必须要么全部执行成功,要么全部执行失败(回滚)

### ACID是事务的四个基本特性

    原子性(Atomicity):一个事务中所有操作全部完成或失败
    一致性(Consistency):事务开始和结束之后数据完整性没有被破坏
    隔离性(Isolation):允许多个事务同时对数据库修改和读写
    持久性(Durability):事务结束之后,修改是永久的不会丢失

### 事务的并发控制

如果不对事务进行并发控制,可能会产生四种异常情况

    幻读(phantom read):一个事务第二次查出现第一次没有的结果
    非重复读(nonrepeatable read):一个事务重复读两次得到不同结果
    脏读(dirty read):一个事务读取到另一个事务没有提交的修改
    丢失修改(lost update):并发写入造成其中一些修改丢失

### 四种事务隔离级别

为了解决并发控制异常,定义了4种事务隔离级别

    读未提交(read uncommitted):别的事物可以读取到未提交改变
    读已提交(read committed):只能读取已经提交的数据
    可重复读(repeatable read):同一个事务先后查询结果一样(Mysql innodb默认)
    串行话(Serializable):事务完全串行化的执行,隔离级别最高,执行效率最低

### 如何解决高并发场景下的插入重复

高并发场景下,写入数据库会有数据重复问题

    使用数据库的唯一索引
    使用队列异步导入
    使用redis等实现分布式锁

### 乐观锁和悲观锁

    悲观锁是先获取锁再操作.一锁二查三更新 select for update
    乐观锁先修改,更新的时候发现数据已经变了就回滚(check and set)
    乐观锁一般通过版本号或者时间戳实现
    需要根据响应速度,冲突频率,重试代价来判断使用哪一种

### InnoDB vs MyISAM

    MyISAM不支持事务,InnoDB支持事务
    MyISAM不支持外键,InnoDB支持外键
    MyISAM只支持表锁,InnoDB支持行锁和表锁
    MyISAM支持全文索引,InnoDB不支持全文索引

## Mysql索引原理及优化

### 什么是索引

    索引是数据表中一个或者多个列进行排序的数据结构
    索引能够大幅提升检索速度(查找结构)
    创建,更新索引本身也会耗费空间和时间

### 什么是B-Tree

    多路平衡查找数(每个节点最多m(m>=2)个孩子,成为m阶或者度)
    叶节点具有相同的深度
    节点中的数据key从左到右是递增的

### B+Tree

B+树是B-Tree的变形

    Mysql实际使用的B+Tree作为索引的数据结构
    只在叶子节点带有指向记录的指针(可以增加树的度)
    叶子节点通过指针相连.(实现范围查询)

### Mysql索引的类型

    普通索引(CREATE INDEX)
    唯一索引,索引列的值必须唯一(CREATE UNIQUE INDEX)
    多列索引
    主键索引(PRIMARY KEY),一个表只能有一个
    全文索引(FULLTEXT INDEX), InnoDB不支持

### 什么时候创建索引

建表的时候需要根据查询需求来创建索引

    经常用做查询条件的字段(WHERE条件)
    经常用作表连接的字段
    经常出现在order by, group by之后的字段

### 创建索引有哪些需要注意的

    非空字段 NOT NULL, Mysql很难对空值作查询优化
    区分度高,离散度大,作为索引的字段值尽量不要有大量相同值
    索引的长度不要太长(比较消耗时间)

### 索引什么时候失效

模糊匹配,类型隐转,最左匹配

    以%开头的LIKE语句,模糊搜索
    出现隐式类型转换(在Python这种动态语言查询中需要注意)
    没有满足最左前缀原则

### 什么是聚集索引和非聚集索引

    聚集还是非聚集指的是B+Tree叶节点存的是指针还是数据记录
    MyISAM索引和数据分离,使用的是非聚集索引
    InnoDB数据文件就是索引文件,主键索引就是聚集索引

### 如何排查慢查询

慢查询通常是缺少索引,索引不合理或者业务代码实现导致

    slow_query_log_file 开启并且查询慢查询日志
    通过explain排查索引问题
    调整数据修改索引;业务代码层限制不合理访问

## Redis

### 什么是缓存?为什么要使用缓存

主要讨论的是内存缓存(常见的有Redis和Memcached)

    缓解关系数据库(常见的是Mysql)并发访问的压力:热点数据
    减少响应时间:内存IO速度比磁盘快
    提升吞吐量:Redis等内存数据库单机就可以支撑很大并发

### Redis常用数据类型和使用场景

    String(字符串):用来实现简单的KV键值对存储,比如计数器
    List(链表):实现双向链表,比如用户的关注,粉丝列表
    Hash(哈希表):用来储存彼此相关信息的键值对
    Set(集合):存储不重复元素,比如用户的关注着
    Sorted Set(有序集合):实时信息排行榜

### Redis内置实现

    String:整数或者sds(Simple Dynamic String)
    List:ziplist或者double linked list
    Hash:ziplist或者hashtable
    Set:intset或者hashtable
    SortedSet:skiplist跳跃表

### Redis有哪些持久化方式

    快照方式:把数据快照放在磁盘二进制文件中,dump.rdb
    AOF(Append Only File):每一个写命令追加到appendonly.aof中
    可以通过修改Redis配置实现

### 什么是Redis事务

    将多个请求打包,一次性,按序执行多个命令的机制
    Redis通过MULTI,EXEC,WATCH等命令实现事务功能
    Python redis-py pipline=conn.pipeline(transaction=True)

### Redis如何实现分布式锁

    使用setnx实现加锁,可以同时通过expire添加超时时间
    锁的value值可以使用一个随机的uuid或者特定的命名
    释放锁的时候,通过uuid判断是否是该锁,是则执行delete释放锁

### 使用缓存的模式

    Cache Aside:同时更新缓存和数据库
    Read/Write Through:先更新缓存,缓存定期异步更新数据库
    Write Behind Caching:先更新缓存,缓存定期异步更新数据库

### 如何解决缓存穿透问题

大量查询不到的数据的请求落到后端数据库,数据库压力增大

    由于大量缓存查不到就去数据库取,数据库也没有要查的数据
    解决:对于没查到返回为None的数据也缓存
    插入数据的时候删除相应缓存,或者设置较短的超时时间

### 如何解决缓存击穿问题

某些非常热点的数据key过期,大量请求打到后端数据库

    热点数据key失效导致大量请求打到数据库增加数据库压力
    分布式锁:获取锁的线程从数据库拉数据更新缓存,其他线程等待
    异步后台更新:后台任务针对过期的key自动刷新

### 如何解决缓存血崩问题

缓存不可用或者大量缓存key同时失效,大量请求直接打到数据库

    多级缓存:不同级别的key设置不同的超时时间
    随机超时:key的超时时间随机设置,防止同时超时
    架构层:提升系统可用性.监控,报警完善
