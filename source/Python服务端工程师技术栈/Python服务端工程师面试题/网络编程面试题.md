# 网络编程面试题

TCP 和 UDP 的区别

```python
1.基于连接与无连接；
2.对系统资源的要求（TCP较多,UDP少）；
3.UDP程序结构较简单；
4.流模式与数据报模式 ；
5.TCP保证数据正确性,UDP可能丢包,TCP保证数据顺序,UDP不保证

             TCP            UDP
是否连接     面向连接       面向非连接
传输可靠性   可靠           不可靠
应用场合     少量数据       传输大量数据
速度         慢             快
```

简要介绍三次握手和四次挥手

```python
（1）第一次握手:客户端发送SYN包（SYN=j）到服务器,并进入SYN_SEND状态,等待服务器确认
（2）第二次握手:服务器收到SYN包,必须确认客户的SYN（ACK=j+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态
（3）第三次握手:客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK（ACK=k+1）,此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手
完成三次握手,客户端与服务器开始传送数据

由于TCP连接是全双工的,连接的拆除需要发送四个包,因此称为“四次挥手”.客户端或服务器均可主动发起挥手动作,在socket编程中,任何一方执行close()操作即可产生挥手操作
（1）第一次挥手:客户端发送一个FIN,用来关闭客户到服务器的数据传送.
（2）第二次挥手:服务器收到这个FIN,它发回一个ACK,确认序号为收到的序号加1
（3）第三次挥手:服务器关闭与客户端的连接,发送一个FIN给客户端.
（4）第四次挥手:客户端发回ACK报文确认,并将确认序号设置为收到序号加1
```

什么是粘包 socket 中造成粘包的原因是什么 哪些情况会发生粘包现象

```python
1、粘包的概念
粘包:多个数据包被连续存储于连续的缓存中,在对数据包进行读取时由于无法确定发生方的发送边界,而采用某一估测值大小来进行数据读出,若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包,从接收缓冲区看,后一包数据的头紧接着前一包数据的尾
2、出现粘包的原因
出现粘包现象的原因是多方面的,它既可能由发送方造成,也可能由接收方造成
发送方引起的粘包是由TCP协议本身造成的,TCP为提高传输效率,发送方往往要收集到足够多的数据后才发送一包数据.若连续几次发送的数据都很少,通常TCP会根据优化算法把这些数据合成一包后一次发送出去,这样接收方就收到了粘包数据
接收方引起的粘包是由于接收方用户进程不及时接收数据,从而导致粘包现象.这是因为接收方先把收到的数据放在系统接收缓冲区,用户进程从该缓冲区取数据,若下一包数据到达时前一包数据尚未被用户进程取走,则下一包数据放到系统接收缓冲区时就接到前一包数据之后,而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据,这样就一次取到了多包数据
4、粘包的处理方式:
（1）当时短连接的情况下,不用考虑粘包的情况
（2）如果发送数据无结构,如文件传输,这样发送方只管发送,接收方只管接收存储就ok,也不用考虑粘包
（3）如果双方建立长连接,需要在连接后一段时间内发送不同结构数据
接收方创建预处理线程,对接收到的数据包进行预处理,将粘连的包分开；
分包是指在出现粘包的时候我们的接收方要进行分包处理.（在长连接中都会出现） 数据包的边界发生错位,导致读出错误的数据分包,进而曲解原始数据含义
粘包情况有两种,一种是粘在一起的包都是完整的数据包,另一种情况是粘在一起的包有不完整的包
```
