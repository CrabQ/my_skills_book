# Redis缓存的使用与优化

## 缓存的收益和成本

收益

```shell
加速读写
降低后端负载
```

成本

```shell
数据不一致: 缓存层和数据层时间窗口不一致,和更新策略有关
代码维护成本: 多了一层缓存逻辑
运维成本: 例如Redis Cluster
```

使用场景

```shell
降低后端负载: 对高消耗的SQL:join结果集/分组统计结果缓存
加速请求相应: 利用Redis/Memcache优化IO相应时间
大量写合并为批量写: 如计数器先Redis累加再批量写DB
```

## 缓存更新策略

```shell
# LRU/LFU/FIFO算法剔除: 例如maxmemory-policy,一致性最差,维护成本低
# 超时剔除: 例如expire,一致性教差,维护成本低
# 主动更新: 开发控制生命周期,一致性最强,维护成本高

# 假设最大内存使用量为2MB
Congfig Set maxmemory 2mb
# 当Redis使用的空间达到最大值时自动使用LRU算法删除某些不常用的Key对象
Congfig Set maxmemory-policy allkeys- lru
```

建议

```shell
低一致性: 最大内存和淘汰策略
高一致性: 超时剔除和主动更新结合,最大内存和淘汰策略兜底
```

## 缓存粒度控制

```shell
通用性: 全量属性更好
占用空间: 部分属性更好
代码维护: 表面上全量属性更好
综合考虑
```

## 缓存穿透问题

大量请求不命中

原因

```shell
业务代码自身问题
恶意攻击,爬虫等
```

发现问题

```shell
业务的响应时间
业务本身问题
相关指标: 总调用数,缓存层命中数,存储层命中数
```

解决办法

```shell
1. 缓存空对象
问题: 需要更多的键,缓存层和存储数据'短期'不一致

2. 布隆过滤器
```

## 无底洞问题

问题关键点

```shell
更多的机器 != 更高的性能
批量接口需求(mget, mset等)
数据增长与水平拓展需求
```

优化IO的几种方法

```shell
命令本身优化: 例如慢查询kyes, hgetall, bigkey
减少网络通信次数
降低接入成本: 例如客户端长连接/连接池,NIO等
# 参考集群批量操作优化
```

## 热点key的重建优化

三个目标

```shell
减少重缓存的次数
数据尽可能一致
减少潜在风险
```

互斥锁(mutex key)

```shell
只有一个线程去获取缓存进行重建,其他线程等待
思路简单,保证一致性
代码复杂度增加,存在死锁风险
```

永不过期

```shell
缓存层面: 没有设置过期时间(无expire)
功能层面: 为每个value添加逻辑过期时间,发现超过逻辑过期时间之后,会使用单独的线程去勾线缓存
基本杜绝热点key重建问题
不保证一致性,逻辑过期时间增加维护成本和内存成本
```
